<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Starknet Stealth Addresses</title>
  <script src="https://cdn.jsdelivr.net/npm/get-starknet@3.0.1/dist/index.global.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      background: #0a0a0a;
      color: #e0e0e0;
      min-height: 100vh;
      padding: 2rem;
      line-height: 1.6;
    }
    
    .container { max-width: 900px; margin: 0 auto; }
    
    header {
      text-align: center;
      margin-bottom: 2rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid #222;
    }
    
    h1 {
      font-size: 1.4rem;
      font-weight: 400;
      letter-spacing: 0.1em;
      color: #fff;
      margin-bottom: 0.5rem;
    }
    
    .subtitle { color: #666; font-size: 0.85rem; }
    
    .network-badge {
      display: inline-block;
      background: #1a3a1a;
      color: #4ade80;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.75rem;
      margin-top: 0.75rem;
    }

    .wallet-section {
      background: #111;
      border: 1px solid #222;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .wallet-info { font-size: 0.8rem; }
    .wallet-address { color: #4ade80; font-size: 0.75rem; margin-top: 0.25rem; }

    .wallet-select-label {
      display: block;
      margin-top: 0.5rem;
      color: #666;
      font-size: 0.7rem;
    }

    .wallet-select {
      margin-top: 0.25rem;
      background: #0a0a0a;
      border: 1px solid #222;
      color: #ddd;
      border-radius: 4px;
      padding: 0.35rem 0.5rem;
      font-size: 0.75rem;
    }
    
    .connect-btn {
      background: #4ade80;
      color: #000;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85rem;
      font-weight: 500;
      transition: all 0.2s;
    }
    
    .connect-btn:hover { background: #86efac; }
    .connect-btn:disabled { background: #333; color: #666; cursor: not-allowed; }

    .disconnect-btn {
      background: #7f1d1d;
      color: #fecaca;
      border: none;
      padding: 0.75rem 1.25rem;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.85rem;
      font-weight: 500;
      transition: all 0.2s;
    }
    
    .disconnect-btn:hover { background: #991b1b; }
    .disconnect-btn:disabled { background: #333; color: #666; cursor: not-allowed; }

    .link-button {
      background: transparent;
      border: none;
      color: #4ade80;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.75rem;
      padding: 0;
    }

    .link-button:hover { text-decoration: underline; }

    .debug-panel {
      display: none;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 4px;
      padding: 1rem;
      margin-bottom: 1rem;
      font-size: 0.7rem;
    }

    .step {
      background: #111;
      border: 1px solid #222;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1rem;
    }
    
    .step.disabled { opacity: 0.5; pointer-events: none; }
    
    .step-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    
    .step-number {
      background: #222;
      color: #666;
      width: 26px;
      height: 26px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
    }
    
    .step-number.active { background: #4ade80; color: #000; }
    .step-title { font-size: 0.9rem; color: #fff; }
    .step-desc { color: #666; font-size: 0.8rem; margin-bottom: 1rem; }
    
    button {
      background: #1a1a1a;
      color: #fff;
      border: 1px solid #333;
      padding: 0.6rem 1.2rem;
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.8rem;
      transition: all 0.2s;
    }
    
    button:hover { background: #252525; border-color: #444; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    .btn-primary {
      background: #1a3a1a;
      border-color: #2d5a2d;
      color: #4ade80;
    }
    
    .btn-primary:hover { background: #2d5a2d; }

    input {
      background: #0a0a0a;
      border: 1px solid #222;
      color: #fff;
      padding: 0.6rem;
      border-radius: 4px;
      font-family: inherit;
      font-size: 0.8rem;
      width: 100%;
      margin-bottom: 0.5rem;
    }
    
    input:focus { outline: none; border-color: #444; }
    
    .input-group { margin-bottom: 1rem; }
    .input-label { color: #666; font-size: 0.75rem; margin-bottom: 0.25rem; }

    .output {
      background: #050505;
      border: 1px solid #1a1a1a;
      border-radius: 4px;
      padding: 1rem;
      margin-top: 1rem;
      font-size: 0.75rem;
    }
    
    .output-row {
      display: flex;
      margin-bottom: 0.5rem;
      align-items: flex-start;
    }
    
    .output-label {
      color: #666;
      width: 120px;
      flex-shrink: 0;
    }
    
    .output-value {
      color: #4ade80;
      word-break: break-all;
    }

    .tx-link {
      color: #60a5fa;
      text-decoration: none;
      font-size: 0.75rem;
    }
    
    .tx-link:hover { text-decoration: underline; }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-size: 0.75rem;
      margin-top: 0.75rem;
    }
    
    .status.pending { background: #1a1a3a; color: #93c5fd; }
    .status.success { background: #1a3a1a; color: #4ade80; }
    .status.error { background: #3a1a1a; color: #f87171; }

    .network-warning {
      margin-top: 0.75rem;
      font-size: 0.85rem;
      font-weight: 600;
      color: #fecaca;
      background: #3a1a1a;
      border: 1px solid #7f1d1d;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      text-align: center;
    }

    .info-panel {
      background: #0f0f0f;
      border: 1px solid #222;
      border-radius: 10px;
      padding: 1rem;
      margin-bottom: 1rem;
    }

    .info-panel h3 {
      font-size: 0.85rem;
      color: #fff;
      margin-bottom: 0.5rem;
    }

    .info-panel ul {
      margin-left: 1rem;
      font-size: 0.8rem;
      color: #bbb;
    }

    .info-panel li + li {
      margin-top: 0.35rem;
    }

    .costs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
      margin-top: 1rem;
    }

    .costs-card {
      background: #0b0b0b;
      border: 1px solid #222;
      border-radius: 6px;
      padding: 1rem;
    }

    .costs-title {
      font-size: 0.85rem;
      color: #fff;
      margin-bottom: 0.5rem;
    }

    .costs-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.75rem;
    }

    .costs-table th,
    .costs-table td {
      padding: 0.35rem 0;
      border-bottom: 1px solid #1a1a1a;
      text-align: left;
    }

    .costs-table th {
      color: #666;
      font-weight: 400;
    }

    .costs-total {
      color: #4ade80;
      font-weight: 500;
    }

    .spinner {
      width: 14px;
      height: 14px;
      border: 2px solid transparent;
      border-top-color: currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin { to { transform: rotate(360deg); } }

    .divider { height: 1px; background: #222; margin: 1rem 0; }

    .info-box {
      background: #0f172a;
      border: 1px solid #1e3a5f;
      border-radius: 4px;
      padding: 1rem;
      margin-top: 1rem;
      font-size: 0.75rem;
      color: #93c5fd;
    }

    .milestone {
      background: #0b1a0b;
      border: 1px solid #2d5a2d;
      border-radius: 4px;
      padding: 0.6rem 0.8rem;
      margin-bottom: 0.75rem;
      font-size: 0.75rem;
      color: #9ae6b4;
    }

    .next-steps {
      background: #111827;
      border: 1px solid #1f2937;
      border-radius: 4px;
      padding: 0.75rem;
      margin-top: 0.75rem;
      font-size: 0.75rem;
      color: #cbd5e1;
    }

    .contracts-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid #222;
    }

    .contract-item h4 {
      font-size: 0.7rem;
      color: #666;
      font-weight: normal;
      margin-bottom: 0.25rem;
    }

    .contract-item code {
      font-size: 0.65rem;
      color: #888;
      word-break: break-all;
    }

    .tabs {
      display: flex;
      border-bottom: 1px solid #222;
      margin-bottom: 1.5rem;
    }

    .tab {
      padding: 0.75rem 1.25rem;
      cursor: pointer;
      color: #666;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
      font-size: 0.85rem;
    }

    .tab:hover { color: #888; }
    .tab.active { color: #fff; border-bottom-color: #4ade80; }

    .tab-content { display: none; }
    .tab-content.active { display: block; }

    .event-log {
      background: #050505;
      border: 1px solid #1a1a1a;
      border-radius: 4px;
      padding: 1rem;
      max-height: 300px;
      overflow-y: auto;
      font-size: 0.7rem;
    }

    .event-item {
      padding: 0.5rem 0;
      border-bottom: 1px solid #111;
    }

    .event-item:last-child { border-bottom: none; }

    .match-badge {
      background: #4ade80;
      color: #000;
      padding: 0.1rem 0.4rem;
      border-radius: 2px;
      font-size: 0.65rem;
      font-weight: bold;
    }

    .footer {
      text-align: center;
      margin-top: 2rem;
      padding-top: 1.5rem;
      border-top: 1px solid #222;
      color: #444;
      font-size: 0.7rem;
    }

    .footer a { color: #666; text-decoration: none; }
    .footer a:hover { color: #888; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>STARKNET STEALTH ADDRESSES</h1>
      <p class="subtitle">Stealth address demo: recipient unlinkability (amounts remain public)</p>
      <p class="subtitle">Create stealth addresses and complete the full flow for under 1 cent (est.). 0.0477 STRK ≈ 0.0038 USDC at 0.08 USDC/STRK.</p>
      <p class="subtitle">Comments: Telegram @espejelomar, X @omarespejel, GitHub @omarespejel, omar@starknet.org</p>
      <span id="network-badge" class="network-badge">Sepolia Testnet</span>
      <div id="network-warning" class="network-warning" style="display: none;"></div>
    </header>

    <!-- Wallet Connection -->
    <div class="wallet-section">
      <div class="wallet-info">
        <div id="wallet-status">Connect your wallet to interact with contracts</div>
        <div id="wallet-address" class="wallet-address"></div>
        <label class="wallet-select-label" for="wallet-preference">Wallet preference</label>
        <select id="wallet-preference" class="wallet-select">
          <option value="auto">Auto (show chooser if available)</option>
          <option value="argentx">ArgentX</option>
          <option value="braavos">Braavos</option>
        </select>
      </div>
      <div style="display: flex; gap: 0.5rem; align-items: center;">
        <button id="connect-btn" class="connect-btn" onclick="connectWallet()">
          Connect Wallet
        </button>
        <button id="disconnect-btn" class="disconnect-btn" onclick="disconnectWallet()" disabled>
          Disconnect
        </button>
      </div>
    </div>

    <div id="pre-tx-warning" class="network-warning" style="display: none;"></div>

    <div style="margin-bottom: 0.5rem;">
      <button id="debug-toggle" class="link-button" onclick="toggleDebugPanel()">Show Wallet Debug</button>
      <button class="link-button" onclick="resetDemo()" style="margin-left: 0.75rem;">Reset Demo</button>
    </div>

    <!-- Debug Panel -->
    <div id="debug-panel" class="debug-panel">
      <div style="color: #888; margin-bottom: 0.5rem;">Wallet Detection Debug:</div>
      <div id="debug-output" style="color: #4ade80; font-family: monospace;"></div>
      <button onclick="detectWallets()" style="margin-top: 0.5rem; font-size: 0.7rem;">Re-detect Wallets</button>
    </div>

    <div class="info-panel">
      <h3>How it works (TL;DR)</h3>
      <ul>
        <li>Recipient registers a meta-address (public keys) on-chain once.</li>
        <li>Sender derives a unique stealth address with ECDH and announces it.</li>
        <li>Recipient scans announcements, derives a one-time spend key, and spends.</li>
      </ul>
    </div>

    <div class="info-panel">
      <h3>Privacy Notes</h3>
      <ul>
        <li>Announcements are permissionless and can be spammed.</li>
        <li>View tags speed up scanning but don’t hide sender addresses.</li>
        <li>Amounts remain visible without a privacy layer (e.g., Tongo).</li>
      </ul>
    </div>

    <div class="tabs">
      <div class="tab active" data-tab="receive" onclick="showTab('receive')">Receive (Alice)</div>
      <div class="tab" data-tab="send" onclick="showTab('send')">Send (Bob)</div>
      <div class="tab" data-tab="scan" onclick="showTab('scan')">Scan</div>
    </div>

    <!-- SEND TAB (Bob's perspective) -->
    <div id="send-tab" class="tab-content">
      <!-- Flow Overview -->
      <div class="flow-overview" style="background: linear-gradient(135deg, rgba(78, 205, 196, 0.1), rgba(255, 107, 107, 0.1)); border: 1px solid rgba(78, 205, 196, 0.3); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem;">
        <div style="font-weight: 600; color: #4ecdc4; margin-bottom: 0.5rem;">Stealth Payment Flow (4 Steps)</div>
        <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.8rem; color: #ccc;">
          <div style="text-align: center; flex: 1;">
            <div style="font-size: 1.2rem; margin-bottom: 0.25rem;">1</div>
            <div>Lookup</div>
            <div style="font-size: 0.65rem; color: #888;">Get recipient's key</div>
          </div>
          <div style="color: #4ecdc4;">&#8594;</div>
          <div style="text-align: center; flex: 1;">
            <div style="font-size: 1.2rem; margin-bottom: 0.25rem;">2</div>
            <div>Generate</div>
            <div style="font-size: 0.65rem; color: #888;">Create stealth addr</div>
          </div>
          <div style="color: #4ecdc4;">&#8594;</div>
          <div style="text-align: center; flex: 1;">
            <div style="font-size: 1.2rem; margin-bottom: 0.25rem;">3</div>
            <div>Deploy</div>
            <div style="font-size: 0.65rem; color: #888;">Create account</div>
          </div>
          <div style="color: #4ecdc4;">&#8594;</div>
          <div style="text-align: center; flex: 1;">
            <div style="font-size: 1.2rem; margin-bottom: 0.25rem;">4</div>
            <div style="color: #ff6b6b; font-weight: 600;">Fund</div>
            <div style="font-size: 0.65rem; color: #888;">Send STRK</div>
          </div>
        </div>
        <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 6px; font-size: 0.75rem; color: #888;">
          <strong style="color: #4ecdc4;">Privacy:</strong> You know who you're paying, but observers cannot link this payment to other payments the recipient receives.
        </div>
      </div>

      <div class="info-box" style="margin-top: 0; margin-bottom: 1.25rem;">
        <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
          <input type="checkbox" id="tongo-toggle" onchange="toggleTongoNote()" style="margin: 0;">
          <span>Send via Tongo (optional amount privacy)</span>
        </label>
        <div id="tongo-note" style="display: none; margin-top: 0.75rem; color: #cbd5e1;">
          <div style="margin-bottom: 0.35rem;"><strong>Tongo flow notes:</strong></div>
          <ul style="margin: 0.35rem 0 0 1rem; padding: 0;">
            <li>Fund/withdraw are public ERC-20 amounts (entry/exit visible).</li>
            <li>Transfers inside Tongo are amount-private via encrypted balances + ZK proofs.</li>
            <li>Transfers credit a pending balance; the recipient must call rollover to spend.</li>
          </ul>
          <div style="margin-top: 0.5rem; color: #93c5fd;">This demo does not execute Tongo transactions.</div>
        </div>
      </div>

      <!-- Step 1: Get recipient meta-address -->
      <div class="step" id="step-1">
        <div class="step-header">
          <span class="step-number">1</span>
          <span class="step-title">Enter Recipient's Meta-Address</span>
        </div>
        <p class="step-desc">Get the recipient's public key from the registry or paste it directly.</p>
        
        <div class="input-group">
          <div class="input-label">Recipient Starknet Address (to lookup)</div>
          <input type="text" id="lookup-address" placeholder="0x...">
        </div>
        <button onclick="lookupMetaAddress()">Lookup from Registry</button>
        
        <div class="divider"></div>
        
        <div class="input-group">
          <div class="input-label">Or paste Spending Key X directly</div>
          <input type="text" id="recipient-key-x" placeholder="0x...">
        </div>
        <div class="input-group">
          <div class="input-label">Spending Key Y</div>
          <input type="text" id="recipient-key-y" placeholder="0x...">
        </div>
        
        <div id="lookup-output" class="output" style="display: none;"></div>
      </div>

      <!-- Step 2: Generate stealth address -->
      <div class="step" id="step-2">
        <div class="step-header">
          <span class="step-number">2</span>
          <span class="step-title">Generate Stealth Address</span>
        </div>
        <p class="step-desc">Compute a one-time stealth address using ECDH key exchange.</p>
        
        <button class="btn-primary" onclick="generateStealth()">Generate Stealth Address</button>
        
        <div id="stealth-output" class="output" style="display: none;"></div>
      </div>

      <!-- Step 3: Deploy & Announce -->
      <div class="step" id="step-3">
        <div class="step-header">
          <span class="step-number">3</span>
          <span class="step-title">Deploy Account & Announce</span>
        </div>
        <p class="step-desc">Deploy the stealth account on-chain and publish the announcement.</p>
        
        <button class="btn-primary" onclick="deployAndAnnounce()" id="deploy-btn" disabled>
          Deploy & Announce
        </button>
        
        <div id="deploy-output" class="output" style="display: none;"></div>
      </div>

      <!-- Step 4: Fund the Stealth Address -->
      <div class="step" id="step-4" style="display: none;">
        <div class="step-header">
          <span class="step-number">4</span>
          <span class="step-title">Fund the Stealth Address</span>
        </div>
        <p class="step-desc">Send STRK to the stealth address so the recipient can use it. (Optional: a paymaster can cover fees to make this step smoother.)</p>
        
        <div class="input-group">
          <div class="input-label">Stealth Address (copy this)</div>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <input type="text" id="fund-stealth-address" readonly style="flex: 1; font-family: monospace; font-size: 0.85rem;">
            <button onclick="copyFundAddress()" style="padding: 0.5rem 1rem;">Copy</button>
          </div>
        </div>
        
        <div class="input-group">
          <div class="input-label">Amount (STRK)</div>
          <input type="text" id="fund-amount" placeholder="0.1" value="0.1">
        </div>
        
        <button class="btn-primary" onclick="fundStealthAddress()" id="fund-btn">
          Send STRK to Stealth Address
        </button>
        
        <div id="fund-output" class="output" style="display: none;"></div>
        
        <div class="info-box" style="margin-top: 1rem; padding: 1rem; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 3px solid #4ecdc4;">
          <strong>Complete Flow:</strong>
          <ol style="margin: 0.5rem 0 0 1.5rem; padding: 0;">
            <li>You (Bob) generated a stealth address for the recipient</li>
            <li>You deployed the stealth account on-chain</li>
            <li>You announced the payment (so recipient can find it)</li>
            <li><strong>Now: Send STRK to fund the stealth account</strong></li>
            <li>Recipient scans, finds the payment, and can spend the STRK</li>
          </ol>
        </div>
      </div>
    </div>

    <!-- RECEIVE TAB (Alice's perspective) -->
    <div id="receive-tab" class="tab-content active">
      <!-- Flow Overview -->
      <div class="flow-overview" style="background: linear-gradient(135deg, rgba(168, 85, 247, 0.1), rgba(78, 205, 196, 0.1)); border: 1px solid rgba(168, 85, 247, 0.3); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem;">
        <div style="font-weight: 600; color: #a855f7; margin-bottom: 0.5rem;">Recipient Setup (One-Time)</div>
        <div style="font-size: 0.85rem; color: #ccc;">
          Register your meta-address so senders can create private payments to you.
          <br>
          <span style="color: #888; font-size: 0.75rem;">Share your Starknet address with senders - they look up your meta-address from the registry.</span>
        </div>
        <div style="margin-top: 0.75rem; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 6px; font-size: 0.75rem; color: #888;">
          <strong style="color: #a855f7;">Privacy note:</strong> The sender knows they're paying you, but blockchain observers cannot link multiple payments to you - each goes to a unique stealth address.
        </div>
      </div>

      <div class="step">
        <div class="step-header">
          <span class="step-number">1</span>
          <span class="step-title">Generate Your Meta-Address</span>
        </div>
        <p class="step-desc">Generate a new key pair. Save the private key securely - you'll need it to claim payments.</p>
        
        <button onclick="generateRecipientKeys()">Generate New Keys</button>
        
        <div id="recipient-keys-output" class="output" style="display: none;"></div>
      </div>

      <div class="step">
        <div class="step-header">
          <span class="step-number">2</span>
          <span class="step-title">Register Meta-Address On-Chain</span>
        </div>
        <p class="step-desc">Publish your meta-address to the registry so senders can find you.</p>
        
        <div class="input-group">
          <div class="input-label">Your Spending Key X</div>
          <input type="text" id="register-key-x" placeholder="0x...">
        </div>
        <div class="input-group">
          <div class="input-label">Your Spending Key Y</div>
          <input type="text" id="register-key-y" placeholder="0x...">
        </div>
        
        <button class="btn-primary" onclick="registerMetaAddress()" id="register-btn">
          Register On-Chain
        </button>
        <button onclick="updateMetaAddress()" id="update-btn" style="margin-left: 0.5rem;">
          Update On-Chain
        </button>
        
        <div id="register-output" class="output" style="display: none;"></div>
      </div>
    </div>

    <!-- SCAN TAB -->
    <div id="scan-tab" class="tab-content">
      <!-- Flow Overview -->
      <div class="flow-overview" style="background: linear-gradient(135deg, rgba(250, 204, 21, 0.1), rgba(78, 205, 196, 0.1)); border: 1px solid rgba(250, 204, 21, 0.3); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem;">
        <div style="font-weight: 600; color: #facc15; margin-bottom: 0.5rem;">Scan Payments</div>
        <div style="font-size: 0.85rem; color: #ccc;">
          Use your private key to find stealth payments sent to you.
          <br>
          <span style="color: #888; font-size: 0.75rem;">The scanner checks announcements and computes which addresses you control.</span>
        </div>
      </div>

      <div class="step">
        <div class="step-header">
          <span class="step-number">1</span>
          <span class="step-title">Enter Your Private Key</span>
        </div>
        <p class="step-desc">Your spending private key is used to check which announcements are yours.</p>
        
        <div class="input-group">
          <div class="input-label">Your Spending Private Key</div>
          <input type="password" id="scan-private-key" placeholder="0x...">
        </div>

        <div class="input-group">
          <div class="input-label">From Block (optional, reduces scan time)</div>
          <input type="text" id="scan-from-block" placeholder="e.g. 5621500">
        </div>
        
        <button class="btn-primary" onclick="scanAnnouncements()">Scan Announcements</button>
        
        <div id="scan-status" class="status" style="display: none;"></div>
      </div>

      <div class="step">
        <div class="step-header">
          <span class="step-number">2</span>
          <span class="step-title">Results</span>
        </div>
        
        <div id="scan-results" class="event-log">
          <div style="color: #666;">No scan performed yet. Enter your private key and click Scan.</div>
        </div>
      </div>

    </div>

    <!-- Contract Info -->
    <div class="step">
      <div class="step-header">
        <div class="step-number">+</div>
        <div class="step-title">Cost Estimates</div>
      </div>
      <p class="step-desc">
        Based on Sepolia measurements (2026-01-22) and mainnet gas prices at time of estimate.
        USDC estimates assume 0.08 USDC/STRK. Fees vary with network conditions.
      </p>
      <div class="costs-grid">
        <div class="costs-card">
          <div class="costs-title">Sepolia Actual (STRK)</div>
          <table class="costs-table">
            <thead>
              <tr>
                <th>Step</th>
                <th>Fee</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><a class="tx-link" href="https://sepolia.starkscan.co/tx/0x4369df0e44f5ae6c54c3ea02a354f4f0fa0c598927ba19a80627e92cfb05b2e" target="_blank">Register</a></td>
                <td>0.010747</td>
              </tr>
              <tr>
                <td><a class="tx-link" href="https://sepolia.starkscan.co/tx/0x64ff72456d2e41d3634765f37d5319874a8fc54868f0834ac30267d119a7595" target="_blank">Deploy</a></td>
                <td>0.012017</td>
              </tr>
              <tr>
                <td><a class="tx-link" href="https://sepolia.starkscan.co/tx/0x76c476c1233d219ed586de96109a65a5f470d51ed0f5a52d1b42537dabe0f88" target="_blank">Announce</a></td>
                <td>0.009027</td>
              </tr>
              <tr>
                <td><a class="tx-link" href="https://sepolia.starkscan.co/tx/0x264f38f887ea924417653fa46b27420d98551871112701a24a6aa12e4a4ab7a" target="_blank">Fund</a></td>
                <td>0.009112</td>
              </tr>
              <tr>
                <td><a class="tx-link" href="https://sepolia.starkscan.co/tx/0x5cd1be542cbbe214c227469ea577bb206993a9aca85214e1a55403fcb3e7c5f" target="_blank">Spend</a></td>
                <td>0.007832</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="costs-card">
          <div class="costs-title">Mainnet Estimate (STRK)</div>
          <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
          <div style="font-size: 0.75rem; color: #bbb;">STRK price (USDC):</div>
          <input type="text" id="mainnet-strk-price" value="0.08" style="width: 80px;" oninput="renderMainnetUsd()">
          <div id="mainnet-usd-note" style="font-size: 0.7rem; color: #777;">Edit to current price</div>
          </div>
          <table class="costs-table">
            <thead>
              <tr>
                <th>Step</th>
                <th>Fee (STRK)</th>
                <th>USDC (est.)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Register</td>
                <td>0.010427</td>
                <td class="costs-usd" data-mainnet-strk="0.010427">—</td>
              </tr>
              <tr>
                <td>Deploy</td>
                <td>0.011627</td>
                <td class="costs-usd" data-mainnet-strk="0.011627">—</td>
              </tr>
              <tr>
                <td>Announce</td>
                <td>0.008945</td>
                <td class="costs-usd" data-mainnet-strk="0.008945">—</td>
              </tr>
              <tr>
                <td>Fund</td>
                <td>0.008937</td>
                <td class="costs-usd" data-mainnet-strk="0.008937">—</td>
              </tr>
              <tr>
                <td>Spend</td>
                <td>0.007778</td>
                <td class="costs-usd" data-mainnet-strk="0.007778">—</td>
              </tr>
              <tr>
                <td class="costs-total">Total</td>
                <td class="costs-total">0.047713</td>
                <td class="costs-total costs-usd" data-mainnet-strk="0.047713">—</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="contracts-info">
      <div class="contract-item">
        <h4>StealthRegistry</h4>
        <code>0x30e391e0...c1f0</code>
        <br>
        <a href="https://sepolia.starkscan.co/contract/0x30e391e0fb3020ccdf4d087ef3b9ac43dae293fe77c96897ced8cc86a92c1f0" target="_blank" class="tx-link">View on Explorer</a>
      </div>
      <div class="contract-item">
        <h4>StealthAccountFactory</h4>
        <code>0x2175848f...5085</code>
        <br>
        <a href="https://sepolia.starkscan.co/contract/0x2175848fdac537a13a84aa16b5c1d7cdd4ea063cd7ed344266b99ccc4395085" target="_blank" class="tx-link">View on Explorer</a>
      </div>
    </div>

    <footer>
      <p>
        <a href="https://github.com/omarespejel/starknet-stealth-addresses" target="_blank">Source Code</a>
        &nbsp;|&nbsp;
        <a href="https://community.starknet.io" target="_blank">SNIP Discussion</a>
      </p>
    </footer>
  </div>

  <script>
    // Configuration - Updated 2026-01-22 with latest deployments
    const CONFIG = {
      registryAddress: '0x30e391e0fb3020ccdf4d087ef3b9ac43dae293fe77c96897ced8cc86a92c1f0',
      factoryAddress: '0x2175848fdac537a13a84aa16b5c1d7cdd4ea063cd7ed344266b99ccc4395085',
      accountClassHash: '0x30d37d3acccb722a61acb177f6a5c197adb26c6ef09cb9ba55d426ebf07a427',
      rpcUrl: 'https://starknet-sepolia.g.alchemy.com/starknet/version/rpc/v0_10/cf52O0RwFy1mEB0uoYsel',
      ethTokenAddress: '0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7',
      strkTokenAddress: '0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d',
      schemeId: '0x0',
    };

    const SEPOLIA_CHAIN_IDS = new Set([
      '0x534e5f5345504f4c4941', // SN_SEPOLIA
      'SN_SEPOLIA'
    ]);
    const MAINNET_CHAIN_IDS = new Set([
      '0x534e5f4d41494e', // SN_MAIN
      'SN_MAIN'
    ]);

    // ABIs
    const REGISTRY_ABI = [
      { type: "function", name: "register_stealth_meta_address", inputs: [{ name: "spending_pubkey_x", type: "felt" }, { name: "spending_pubkey_y", type: "felt" }, { name: "viewing_pubkey_x", type: "felt" }, { name: "viewing_pubkey_y", type: "felt" }, { name: "scheme_id", type: "felt" }], outputs: [] },
      { type: "function", name: "update_stealth_meta_address", inputs: [{ name: "spending_pubkey_x", type: "felt" }, { name: "spending_pubkey_y", type: "felt" }, { name: "viewing_pubkey_x", type: "felt" }, { name: "viewing_pubkey_y", type: "felt" }, { name: "scheme_id", type: "felt" }], outputs: [] },
      { type: "function", name: "get_stealth_meta_address", inputs: [{ name: "user", type: "felt" }], outputs: [{ name: "scheme_id", type: "felt" }, { name: "spending_pubkey_x", type: "felt" }, { name: "spending_pubkey_y", type: "felt" }, { name: "viewing_pubkey_x", type: "felt" }, { name: "viewing_pubkey_y", type: "felt" }] },
      { type: "function", name: "has_meta_address", inputs: [{ name: "user", type: "felt" }], outputs: [{ name: "result", type: "felt" }] },
      { type: "function", name: "announce", inputs: [{ name: "scheme_id", type: "felt" }, { name: "ephemeral_pubkey_x", type: "felt" }, { name: "ephemeral_pubkey_y", type: "felt" }, { name: "stealth_address", type: "felt" }, { name: "view_tag", type: "felt" }, { name: "metadata", type: "felt" }], outputs: [] },
    ];

    const FACTORY_ABI = [
      { type: "function", name: "deploy_stealth_account", inputs: [{ name: "stealth_pubkey_x", type: "felt" }, { name: "stealth_pubkey_y", type: "felt" }, { name: "salt", type: "felt" }], outputs: [{ name: "address", type: "felt" }] },
    ];

    // State
    let wallet = null;
    let account = null;
    let provider = null;
    let stealthData = null;
    let lastMatches = [];
    let lastDeployTxHash = null;
    let lastAnnounceTxHash = null;
    let lastAnnounceCall = null;
    let walletChainId = null;
    let walletOnSepolia = false;
    let chainWatcher = null;
    
    function getProvider() {
      if (account && account.provider) return account.provider;
      if (wallet && wallet.provider) return wallet.provider;
      return null;
    }

    function makeCall(contractAddress, entrypoint, calldata) {
      return { contractAddress, entrypoint, calldata };
    }

    // Selector cache for common entrypoints (computed via starknet.js hash.getSelectorFromName)
    const SELECTORS = {
      'get_stealth_meta_address': '0x1fe2dab6f98370e5953e5bc38fdf82792736325aa05710e4ce3572f2b51371f',
      'has_meta_address': '0x260da1763cad66562bd3525d8fb1e1d1f9f64ae12e60724cbd4515e981c934e',
      'compute_stealth_address': '0x10f1e271ffd103e9df69a616e029c762686cbda63799630a28b25b5fa5c46c7',
      'balanceOf': '0x2e4263afad30923c891518314c3c95dbe830a16874e8abc5777a9a20b54c76e',
    };
    
    async function callContract(contractAddress, entrypoint, calldata) {
      // Use direct RPC for reliability (wallet provider can have network issues)
      const selector = SELECTORS[entrypoint];
      if (!selector) {
        throw new Error(`Unknown entrypoint: ${entrypoint}. Add selector to SELECTORS map.`);
      }
      const result = await rpcRequest('starknet_call', [
        {
          contract_address: contractAddress,
          entry_point_selector: selector,
          calldata: calldata
        },
        'latest'
      ]);
      if (!Array.isArray(result) || result.length === 0) {
        throw new Error('Invalid call result');
      }
      return result;
    }

    let starknetJsPromise = null;
    async function getStarknetModule() {
      if (window.starknetjs && window.starknetjs.RpcProvider && window.starknetjs.Account) {
        return window.starknetjs;
      }

      if (!starknetJsPromise) {
        starknetJsPromise = new Promise((resolve, reject) => {
          try {
            const iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            iframe.src = 'about:blank';
            iframe.onload = () => {
              try {
                const doc = iframe.contentDocument;
                if (!doc) {
                  reject(new Error('starknet.js iframe document not accessible'));
                  return;
                }
                const script = doc.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/starknet@6.21.0/dist/index.global.js';
                script.async = true;
                script.onload = () => {
                  const lib = iframe.contentWindow ? iframe.contentWindow.starknet : null;
                  const isLib = lib && lib.RpcProvider && lib.Account;
                  if (!isLib) {
                    console.error('[starknetjs] Global load failed in iframe');
                    reject(new Error('starknet.js module missing constructors'));
                    return;
                  }
                  window.starknetjs = lib;
                  console.log('[starknetjs] Loaded in iframe');
                  resolve(window.starknetjs);
                };
                script.onerror = () => reject(new Error('Failed to load starknet.js'));
                doc.head.appendChild(script);
              } catch (err) {
                reject(err);
              }
            };
            document.body.appendChild(iframe);
          } catch (err) {
            reject(err);
          }
        });
      }

      return starknetJsPromise;
    }

    function toUint256(amount) {
      const lowMask = (1n << 128n) - 1n;
      return {
        low: (amount & lowMask),
        high: (amount >> 128n)
      };
    }

    function parseAmountToUint256(amountStr) {
      const trimmed = (amountStr || '').trim();
      if (!trimmed) throw new Error('Amount is required');
      const parts = trimmed.split('.');
      if (parts.length > 2) throw new Error('Invalid amount');
      const whole = parts[0] ? BigInt(parts[0]) : 0n;
      const fraction = parts[1] || '';
      if (fraction.length > 18) throw new Error('Too many decimals (max 18)');
      const fracPadded = (fraction + '0'.repeat(18)).slice(0, 18);
      const frac = fracPadded ? BigInt(fracPadded) : 0n;
      const amount = whole * (10n ** 18n) + frac;
      return toUint256(amount);
    }

    function parseAmountToWei(amountStr) {
      const uint = parseAmountToUint256(amountStr);
      return (uint.high << 128n) + uint.low;
    }

    function uint256ToBigInt(lowHex, highHex) {
      const low = BigInt(lowHex);
      const high = BigInt(highHex);
      return (high << 128n) + low;
    }

    function formatUnits(amount, decimals = 18) {
      const base = 10n ** BigInt(decimals);
      const whole = amount / base;
      const frac = amount % base;
      let fracStr = frac.toString().padStart(decimals, '0').replace(/0+$/, '');
      return fracStr ? `${whole}.${fracStr}` : `${whole}`;
    }

    function formatUsd(amount) {
      if (!Number.isFinite(amount)) return '—';
      const decimals = amount < 0.01 ? 4 : 2;
      return `${amount.toFixed(decimals)} USDC`;
    }

    function renderMainnetUsd() {
      const input = document.getElementById('mainnet-strk-price');
      const note = document.getElementById('mainnet-usd-note');
      const price = input ? Number(input.value) : NaN;
      const isValid = Number.isFinite(price) && price > 0;

      if (note) {
        note.textContent = isValid
          ? `Assuming ${price.toFixed(2)} USDC/STRK`
          : 'Enter STRK price to estimate USDC';
      }

      document.querySelectorAll('[data-mainnet-strk]').forEach((cell) => {
        const strkValue = Number(cell.getAttribute('data-mainnet-strk'));
        if (!isValid || !Number.isFinite(strkValue)) {
          cell.textContent = '—';
          return;
        }
        cell.textContent = formatUsd(strkValue * price);
      });
    }

    async function hasMetaAddress(address) {
      const result = await callContract(CONFIG.registryAddress, 'has_meta_address', [address]);
      return BigInt(result[0]) !== 0n;
    }

    function parseMetaAddress(values) {
      if (!Array.isArray(values)) return null;
      try {
        if (values.length >= 5) {
          return {
            schemeId: BigInt(values[0]),
            spendingX: BigInt(values[1]),
            spendingY: BigInt(values[2]),
            viewingX: BigInt(values[3]),
            viewingY: BigInt(values[4])
          };
        }
        if (values.length >= 2) {
          const x = BigInt(values[0]);
          const y = BigInt(values[1]);
          return {
            schemeId: 0n,
            spendingX: x,
            spendingY: y,
            viewingX: x,
            viewingY: y
          };
        }
      } catch (err) {
        console.warn('[parseMetaAddress] Failed to parse:', err.message);
      }
      return null;
    }

    async function computeStealthContractAddress() {
      if (!stealthData) {
        throw new Error('Stealth data not available');
      }
      const values = await callContract(CONFIG.factoryAddress, 'compute_stealth_address', [
        toHex(stealthData.stealthPub.x),
        toHex(stealthData.stealthPub.y),
        toHex(stealthData.salt)
      ]);
      const addr = normalizeAddress(values[0]);
      stealthData.stealthAddress = addr;
      return addr;
    }

    async function rpcRequest(method, params) {
      const payload = {
        jsonrpc: '2.0',
        id: Date.now(),
        method,
        params
      };
      console.log('[rpc] Request:', method, JSON.stringify(params));
      const res = await fetch(CONFIG.rpcUrl, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const body = await res.json();
      if (body.error) {
        console.error('[rpc] Error:', body.error);
        throw new Error(body.error.message || 'RPC error');
      }
      return body.result;
    }

    // Direct RPC call - use callContract instead for known entrypoints
    async function rpcCall(contractAddress, entrypoint, calldata) {
      // If we have a known selector, use the proper format
      if (SELECTORS[entrypoint]) {
        return await callContract(contractAddress, entrypoint, calldata);
      }
      // Fallback for unknown entrypoints - compute selector
      throw new Error(`Unknown entrypoint: ${entrypoint}. Add to SELECTORS map.`);
    }

    async function isContractDeployed(address) {
      try {
        // Use positional params: [block_id, contract_address]
        await rpcRequest('starknet_getClassHashAt', ['latest', normalizeAddress(address)]);
        return true;
      } catch (err) {
        // Contract not found means not deployed
        if (err.message && (err.message.includes('Contract not found') || err.message.includes('not found'))) {
          return false;
        }
        // For other errors, assume not deployed to be safe
        console.warn('[isContractDeployed] Error checking deployment:', err.message);
        return false;
      }
    }

    async function getEventsPage(filter, token) {
      const f = { ...filter };
      if (token) f.continuation_token = token;
      return rpcRequest('starknet_getEvents', [f]);
    }

    async function getScanRange() {
      const manualInput = document.getElementById('scan-from-block');
      const manualValue = manualInput ? manualInput.value.trim() : '';
      if (manualValue) {
        const parsed = Number(manualValue);
        if (!Number.isNaN(parsed) && parsed >= 0) {
          return {
            fromBlock: Math.floor(parsed),
            toBlock: 'latest',
            latest: null,
            source: 'manual'
          };
        }
      }

      let latest = null;
      try {
        latest = await rpcRequest('starknet_blockNumber', []);
      } catch (err) {
        console.warn('[scan] blockNumber failed:', err.message);
      }

      let fromBlock = latest !== null ? Math.max(0, latest - 20000) : 0;
      let toBlock = 'latest';
      let source = 'recent';

      if (lastAnnounceTxHash) {
        try {
          const receipt = await rpcRequest('starknet_getTransactionReceipt', [lastAnnounceTxHash]);
          if (receipt && receipt.block_number !== undefined && receipt.block_number !== null) {
            const b = Number(receipt.block_number);
            fromBlock = Math.max(0, b - 20);
            toBlock = { block_number: b };
            source = 'announce_tx';
          }
        } catch (err) {
          console.warn('[scan] receipt lookup failed:', err.message);
        }
      }

      return { fromBlock, toBlock, latest, source };
    }

    async function fetchAnnouncementEvents() {
      const events = [];
      let token = null;
      let pages = 0;
      const maxPages = 20;

      const range = await getScanRange();
      console.log('[scan] Using block range:', range);

      const baseFilter = {
        from_block: { block_number: range.fromBlock },
        to_block: range.toBlock,
        address: CONFIG.registryAddress,
        chunk_size: 100
      };

      let filter = { ...baseFilter, keys: [] };
      let lastError = null;

      while (pages < maxPages) {
        console.log('[scan] Fetching events page', pages + 1, 'token', token || 'none');
        let result = null;
        try {
          result = await getEventsPage(filter, token);
        } catch (err) {
          lastError = err;
          // Retry with alternate filters in case RPC is strict
          console.warn('[scan] getEvents failed, retrying with alternate filter:', err.message);
          try {
            result = await getEventsPage(baseFilter, token);
          } catch (err2) {
            lastError = err2;
            console.warn('[scan] getEvents failed without keys, retrying with keys:[[]]:', err2.message);
            result = await getEventsPage({ ...baseFilter, keys: [[]] }, token);
          }
        }

        if (result && result.events && result.events.length) {
          events.push(...result.events);
        }
        token = result ? result.continuation_token : null;
        pages += 1;
        if (!token) break;
      }

      if (!events.length && lastError) {
        throw lastError;
      }
      return events;
    }

    async function updateNetworkStatus() {
      const badge = document.getElementById('network-badge');
      const warning = document.getElementById('network-warning');
      const preTxWarning = document.getElementById('pre-tx-warning');
      if (!badge || !warning) return;
      try {
        const chainId = await rpcRequest('starknet_chainId', []);
        const normalizedRpc = normalizeChainId(chainId);
        const isSepolia = normalizedRpc && SEPOLIA_CHAIN_IDS.has(normalizedRpc);
        badge.textContent = isSepolia ? 'Sepolia Testnet' : `RPC: ${normalizedRpc || chainId}`;
        const walletMsg = walletChainId && !SEPOLIA_CHAIN_IDS.has(walletChainId)
          ? ` Wallet is on ${walletChainId}.`
          : '';
        const showWarning = !(isSepolia && (!walletChainId || SEPOLIA_CHAIN_IDS.has(walletChainId)));
        warning.style.display = showWarning ? 'block' : 'none';
        warning.textContent = isSepolia
          ? (walletMsg ? `Warning:${walletMsg} Transactions are disabled until Sepolia is selected. Switch before any on-chain step.` : '')
          : `Warning: RPC is not Sepolia.${walletMsg} Transactions are disabled until Sepolia is selected. Switch before any on-chain step.`;
        if (preTxWarning) {
          preTxWarning.style.display = showWarning ? 'block' : 'none';
          preTxWarning.textContent = warning.textContent;
        }
      } catch (err) {
        warning.style.display = 'block';
        warning.textContent = 'Warning: Failed to detect network from RPC.';
        if (preTxWarning) {
          preTxWarning.style.display = 'block';
          preTxWarning.textContent = warning.textContent;
        }
      }
    }

    function normalizeChainId(chainId) {
      if (!chainId) return null;
      if (typeof chainId === 'bigint') {
        return `0x${chainId.toString(16)}`.toLowerCase();
      }
      if (typeof chainId === 'number') {
        return `0x${chainId.toString(16)}`.toLowerCase();
      }
      if (typeof chainId === 'string') {
        const trimmed = chainId.trim();
        if (trimmed.startsWith('0x') || trimmed.startsWith('0X')) {
          return trimmed.toLowerCase();
        }
        if (/^\d+$/.test(trimmed)) {
          return `0x${BigInt(trimmed).toString(16)}`.toLowerCase();
        }
        return trimmed.toUpperCase();
      }
      return null;
    }

    async function refreshWalletChainId() {
      let chainId = null;
      try {
        if (wallet && wallet.chainId) {
          chainId = wallet.chainId;
        } else if (account && typeof account.getChainId === 'function') {
          chainId = await account.getChainId();
        } else {
          const p = getProvider();
          if (p && typeof p.getChainId === 'function') {
            chainId = await p.getChainId();
          }
        }
      } catch (err) {
        console.warn('[network] Failed to read wallet chain id:', err.message);
      }

      const normalized = normalizeChainId(chainId);
      walletChainId = normalized || chainId;
      walletOnSepolia = normalized ? SEPOLIA_CHAIN_IDS.has(normalized) : false;
      applyNetworkGuard();
      updateNetworkStatus();
      return normalized || chainId;
    }

    function startChainWatcher() {
      if (chainWatcher) return;
      chainWatcher = setInterval(() => {
        if (wallet) {
          refreshWalletChainId();
        }
      }, 3000);
    }

    function stopChainWatcher() {
      if (!chainWatcher) return;
      clearInterval(chainWatcher);
      chainWatcher = null;
    }

    function applyNetworkGuard() {
      const enable = walletOnSepolia;
      const registerBtn = document.getElementById('register-btn');
      const updateBtn = document.getElementById('update-btn');
      const fundBtn = document.getElementById('fund-btn');
      const deployBtn = document.getElementById('deploy-btn');

      if (registerBtn) registerBtn.disabled = !enable;
      if (updateBtn) updateBtn.disabled = !enable;
      if (fundBtn) fundBtn.disabled = !enable;
      if (deployBtn) deployBtn.disabled = !enable || !stealthData;
    }

    async function ensureSepoliaWallet(action) {
      const chainId = walletChainId || await refreshWalletChainId();
      if (!chainId) {
        alert(`Unable to detect wallet network. Please switch to Sepolia before ${action}.`);
        return false;
      }
      const normalized = normalizeChainId(chainId) || chainId;
      if (!SEPOLIA_CHAIN_IDS.has(normalized)) {
        const label = MAINNET_CHAIN_IDS.has(normalized) ? 'mainnet' : normalized;
        alert(`Wallet is on ${label}. Please switch to Sepolia before ${action}.`);
        return false;
      }
      return true;
    }

    async function getStrkBalance(address) {
      const result = await callContract(CONFIG.strkTokenAddress, 'balanceOf', [address]);
      if (!Array.isArray(result) || result.length < 2) {
        throw new Error('Unexpected STRK balance response');
      }
      return uint256ToBigInt(result[0], result[1]);
    }

    async function ensureStrkBalance(action, minStrk = '0.01') {
      if (!account) return true;
      let balance = 0n;
      try {
        balance = await getStrkBalance(account.address);
      } catch (err) {
        alert(`Unable to check STRK balance before ${action}: ${err.message}`);
        return false;
      }

      const minWei = parseAmountToWei(minStrk);
      if (balance < minWei) {
        alert(
          `Insufficient STRK for ${action}. Balance: ${formatUnits(balance)} STRK. ` +
          `Need at least ~${minStrk} STRK for fees.`
        );
        return false;
      }
      return true;
    }

    function resetDemo() {
      stealthData = null;
      lastMatches = [];
      lastDeployTxHash = null;
      lastAnnounceTxHash = null;
      lastAnnounceCall = null;

      const idsToClear = [
        'lookup-address',
        'recipient-key-x',
        'recipient-key-y',
        'fund-stealth-address',
        'scan-private-key',
        'scan-from-block',
        'register-key-x',
        'register-key-y',
      ];
      idsToClear.forEach((id) => {
        const el = document.getElementById(id);
        if (el) el.value = '';
      });

      const fundAmount = document.getElementById('fund-amount');
      if (fundAmount) fundAmount.value = '0.1';

      const deployBtn = document.getElementById('deploy-btn');
      if (deployBtn) {
        deployBtn.disabled = true;
        deployBtn.textContent = 'Deploy & Announce';
      }
      const registerBtn = document.getElementById('register-btn');
      if (registerBtn) registerBtn.textContent = 'Register On-Chain';
      const updateBtn = document.getElementById('update-btn');
      if (updateBtn) updateBtn.textContent = 'Update On-Chain';
      const fundBtn = document.getElementById('fund-btn');
      if (fundBtn) fundBtn.textContent = 'Send STRK to Stealth Address';

      const step4 = document.getElementById('step-4');
      if (step4) step4.style.display = 'none';

      const tongoToggle = document.getElementById('tongo-toggle');
      if (tongoToggle) tongoToggle.checked = false;
      const tongoNote = document.getElementById('tongo-note');
      if (tongoNote) tongoNote.style.display = 'none';

      const outputs = [
        'lookup-output',
        'stealth-output',
        'deploy-output',
        'fund-output',
        'register-output',
        'recipient-keys-output',
      ];
      outputs.forEach((id) => {
        const el = document.getElementById(id);
        if (el) {
          el.style.display = 'none';
          el.innerHTML = '';
        }
      });

      const scanStatus = document.getElementById('scan-status');
      if (scanStatus) scanStatus.style.display = 'none';

      const scanResults = document.getElementById('scan-results');
      if (scanResults) {
        scanResults.innerHTML = '<div style="color: #666;">No scan performed yet. Enter your private key and click Scan.</div>';
      }
    }

    async function waitForTx(txHash) {
      const p = getProvider();
      if (p && typeof p.waitForTransaction === 'function') {
        try {
          const result = await Promise.race([
            p.waitForTransaction(txHash),
            new Promise((_, reject) => setTimeout(() => reject(new Error('waitForTransaction timeout')), 20000))
          ]);
          return result;
        } catch (err) {
          console.warn('[tx] waitForTransaction failed, falling back to RPC:', err.message);
        }
      }
      return waitForTxReceipt(txHash);
    }

    async function waitForTxReceipt(txHash) {
      const maxAttempts = 20;
      const delayMs = 2000;
      for (let i = 0; i < maxAttempts; i += 1) {
        try {
          const receipt = await rpcRequest('starknet_getTransactionReceipt', [txHash]);
          const status = receipt?.finality_status || receipt?.status;
          const exec = receipt?.execution_status;
          if (status === 'ACCEPTED_ON_L2' || status === 'ACCEPTED_ON_L1') {
            if (exec && exec !== 'SUCCEEDED') {
              throw new Error(`Transaction ${exec.toLowerCase()}`);
            }
            return receipt;
          }
          if (status === 'REJECTED') {
            throw new Error('Transaction rejected');
          }
        } catch (err) {
          if (i === maxAttempts - 1) {
            throw err;
          }
        }
        await new Promise((r) => setTimeout(r, delayMs));
      }
      throw new Error('Transaction confirmation timed out');
    }

    async function waitForTxOn(providerInstance, txHash) {
      if (providerInstance && typeof providerInstance.waitForTransaction === 'function') {
        return providerInstance.waitForTransaction(txHash);
      }
      return waitForTx(txHash);
    }

    async function executeWithTimeout(promise, timeoutMs) {
      let timeoutId;
      const timeout = new Promise((resolve) => {
        timeoutId = setTimeout(() => resolve({ timedOut: true, tx: null }), timeoutMs);
      });
      const result = await Promise.race([
        promise.then((tx) => ({ timedOut: false, tx })),
        timeout
      ]);
      clearTimeout(timeoutId);
      return result;
    }

    function renderDeploymentSuccess(deployTxHash, announceTxHash) {
      const output = document.getElementById('deploy-output');
      const deployLink = deployTxHash
        ? `<a href="https://sepolia.starkscan.co/tx/${deployTxHash}" target="_blank" class="tx-link">${truncate(deployTxHash)}</a>`
        : 'n/a';
      const announceLink = announceTxHash
        ? `<a href="https://sepolia.starkscan.co/tx/${announceTxHash}" target="_blank" class="tx-link">${truncate(announceTxHash)}</a>`
        : 'n/a';
      const stealthAddr = (stealthData && stealthData.stealthAddress) ? stealthData.stealthAddress : null;

      output.innerHTML = `
        <div class="milestone">Milestone reached: stealth account deployed and announced.</div>
        <div class="status success">Step 3 complete!</div>
        <div class="divider"></div>
        <div class="output-row">
          <span class="output-label">Deploy TX:</span>
          ${deployLink}
        </div>
        <div class="output-row">
          <span class="output-label">Announce TX:</span>
          ${announceLink}
        </div>
        <div class="output-row">
          <span class="output-label">Stealth Address:</span>
          <span class="output-value">${stealthAddr ? truncate(stealthAddr) : 'n/a'}</span>
        </div>
        <div class="divider"></div>
        <div class="info-box" style="background: #1a2a1a; border-color: #1e5f1e; color: #a5fca5;">
          <strong>Next: Fund the stealth address!</strong>
          <br><br>
          The account is deployed but has no balance. Send STRK to complete the payment.
          <br><br>
          <strong>Note:</strong> A paymaster can sponsor fees here to simplify UX and reduce fee-linkability.
          <br><br>
          <strong>View Tag:</strong> ${stealthData ? stealthData.viewTag : ''}
        </div>
      `;

      // Show step 4 and populate the stealth address
      const step4 = document.getElementById('step-4');
      if (step4 && stealthAddr) {
        step4.style.display = 'block';
        document.getElementById('fund-stealth-address').value = stealthAddr;
      }

      const btn = document.getElementById('deploy-btn');
      btn.textContent = 'Done';
      btn.disabled = true;
    }

    async function finalizeAnnouncement() {
      const input = document.getElementById('announce-tx-hash');
      const hash = input ? input.value.trim() : '';
      const txHash = hash || lastAnnounceTxHash;
      if (!txHash) {
        alert('Please paste the announcement transaction hash from your wallet activity.');
        return;
      }
      const output = document.getElementById('deploy-output');
      output.innerHTML = '<div class="status pending"><div class="spinner"></div>Waiting for announcement confirmation...</div>';
      await waitForTx(txHash);
      renderDeploymentSuccess(lastDeployTxHash, txHash);
    }

    async function retryAnnouncement() {
      if (!account || !lastAnnounceCall) {
        alert('Nothing to retry yet.');
        return;
      }
      if (!await ensureSepoliaWallet('retrying the announcement')) {
        return;
      }
      if (!await ensureStrkBalance('retrying the announcement', '0.01')) {
        return;
      }
      const output = document.getElementById('deploy-output');
      output.innerHTML = '<div class="status pending"><div class="spinner"></div>Submitting announcement...</div>';
      try {
        const announceTx = await account.execute([lastAnnounceCall]);
        lastAnnounceTxHash = announceTx.transaction_hash;
        await waitForTx(lastAnnounceTxHash);
        renderDeploymentSuccess(lastDeployTxHash, lastAnnounceTxHash);
      } catch (err) {
        console.error('Retry announce error:', err);
        output.innerHTML = `<div class="status error">Announcement failed: ${err.message}</div>`;
      }
    }

    // Copy stealth address for funding
    function copyFundAddress() {
      const addr = document.getElementById('fund-stealth-address').value;
      navigator.clipboard.writeText(addr).then(() => {
        const btn = event.target;
        btn.textContent = 'Copied!';
        setTimeout(() => { btn.textContent = 'Copy'; }, 2000);
      });
    }

    // Fund the stealth address with STRK
    async function fundStealthAddress() {
      if (!account) {
        alert('Please connect your wallet first');
        return;
      }
      if (!await ensureSepoliaWallet('funding the stealth address')) {
        return;
      }
      if (!await ensureStrkBalance('funding the stealth address', '0.01')) {
        return;
      }

      const stealthAddr = document.getElementById('fund-stealth-address').value.trim();
      const amountStr = document.getElementById('fund-amount').value.trim();
      const output = document.getElementById('fund-output');
      const btn = document.getElementById('fund-btn');

      if (!stealthAddr || !amountStr) {
        alert('Please enter the stealth address and amount');
        return;
      }

      output.style.display = 'block';
      output.innerHTML = '<div class="status pending"><div class="spinner"></div>Sending STRK to stealth address...</div>';
      btn.disabled = true;

      try {
        const amount = parseAmountToUint256(amountStr);
        
        // Transfer STRK to the stealth address
        const transferCall = {
          contractAddress: CONFIG.strkTokenAddress,
          entrypoint: 'transfer',
          calldata: [
            normalizeAddress(stealthAddr),
            toHex(amount.low),
            toHex(amount.high)
          ]
        };

        const tx = await account.execute([transferCall]);
        output.innerHTML = `
          <div class="status pending"><div class="spinner"></div>Waiting for confirmation...</div>
          <div class="output-row" style="margin-top: 0.5rem;">
            <span class="output-label">TX:</span>
            <a href="https://sepolia.starkscan.co/tx/${tx.transaction_hash}" target="_blank" class="tx-link">${truncate(tx.transaction_hash)}</a>
          </div>
        `;

        await waitForTx(tx.transaction_hash);

        output.innerHTML = `
          <div class="milestone">Milestone reached: stealth payment funded!</div>
          <div class="status success">STRK sent to stealth address!</div>
          <div class="divider"></div>
          <div class="output-row">
            <span class="output-label">TX:</span>
            <a href="https://sepolia.starkscan.co/tx/${tx.transaction_hash}" target="_blank" class="tx-link">${truncate(tx.transaction_hash)}</a>
          </div>
          <div class="output-row">
            <span class="output-label">Amount:</span>
            <span class="output-value">${amountStr} STRK</span>
          </div>
          <div class="output-row">
            <span class="output-label">To:</span>
            <span class="output-value">${truncate(stealthAddr)}</span>
          </div>
          <div class="divider"></div>
          <div class="info-box" style="background: #1a2a1a; border-color: #1e5f1e; color: #a5fca5;">
            <strong>Payment complete!</strong>
            <br><br>
            The recipient can now:
            <ol style="margin: 0.5rem 0 0 1rem; padding: 0;">
              <li>Go to the <strong>Scan</strong> tab</li>
              <li>Enter their private key</li>
              <li>Find this payment</li>
              <li>Spend the ${amountStr} STRK</li>
            </ol>
          </div>
          <div class="next-steps">
            <div style="margin-top: 0.6rem;">
              <button class="btn-primary" onclick="selectTab('scan')">Go to Scan (as recipient)</button>
            </div>
          </div>
        `;

        btn.textContent = 'Funded!';
      } catch (err) {
        console.error('Fund error:', err);
        output.innerHTML = `<div class="status error">Error: ${err.message}</div>`;
        btn.disabled = false;
        btn.textContent = 'Send STRK to Stealth Address';
      }
    }

    // Crypto constants
    const CURVE_ORDER = BigInt('0x800000000000010ffffffffffffffffb781126dcae7b2321e66a241adc64d2f');
    const FIELD_PRIME = BigInt('0x800000000000011000000000000000000000000000000000000000000000001');
    const FIELD_HALF = (FIELD_PRIME - 1n) / 2n;
    const G = {
      x: BigInt('0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca'),
      y: BigInt('0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f')
    };
    const ALPHA = 1n;

    // Tab switching
    function selectTab(tab) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
      const tabEl = document.querySelector(`.tab[data-tab="${tab}"]`);
      if (tabEl) tabEl.classList.add('active');
      const content = document.getElementById(`${tab}-tab`);
      if (content) content.classList.add('active');
    }

    function showTab(tab) {
      selectTab(tab);
    }

    function toggleTongoNote() {
      const toggle = document.getElementById('tongo-toggle');
      const note = document.getElementById('tongo-note');
      if (!toggle || !note) return;
      note.style.display = toggle.checked ? 'block' : 'none';
    }

    // Math helpers
    function mod(n, m) { return ((n % m) + m) % m; }
    
    function modInverse(a, m) {
      let [old_r, r] = [a, m];
      let [old_s, s] = [1n, 0n];
      while (r !== 0n) {
        const q = old_r / r;
        [old_r, r] = [r, old_r - q * r];
        [old_s, s] = [s, old_s - q * s];
      }
      return mod(old_s, m);
    }

    function pointAdd(p1, p2) {
      if (p1 === null) return p2;
      if (p2 === null) return p1;
      if (p1.x === p2.x && p1.y === p2.y) {
        const num = mod(3n * p1.x * p1.x + ALPHA, FIELD_PRIME);
        const den = mod(2n * p1.y, FIELD_PRIME);
        const lam = mod(num * modInverse(den, FIELD_PRIME), FIELD_PRIME);
        const x3 = mod(lam * lam - 2n * p1.x, FIELD_PRIME);
        const y3 = mod(lam * (p1.x - x3) - p1.y, FIELD_PRIME);
        return { x: x3, y: y3 };
      } else {
        const num = mod(p2.y - p1.y, FIELD_PRIME);
        const den = mod(p2.x - p1.x, FIELD_PRIME);
        const lam = mod(num * modInverse(den, FIELD_PRIME), FIELD_PRIME);
        const x3 = mod(lam * lam - p1.x - p2.x, FIELD_PRIME);
        const y3 = mod(lam * (p1.x - x3) - p1.y, FIELD_PRIME);
        return { x: x3, y: y3 };
      }
    }

    function pointMul(k, p) {
      let result = null;
      let addend = p;
      let scalar = k;
      while (scalar > 0n) {
        if (scalar & 1n) result = pointAdd(result, addend);
        addend = pointAdd(addend, addend);
        scalar >>= 1n;
      }
      return result;
    }

    function normalizePoint(point) {
      if (!point) return point;
      if (point.y > FIELD_HALF) {
        return { x: point.x, y: FIELD_PRIME - point.y };
      }
      return point;
    }

    function normalizePrivateKey(privateKey) {
      const pub = pointMul(privateKey, G);
      if (pub && pub.y > FIELD_HALF) {
        return mod(CURVE_ORDER - privateKey, CURVE_ORDER);
      }
      return privateKey;
    }

    function simpleHash(x, y) {
      let h = mod(x * BigInt('0x123456789abcdef') + y, FIELD_PRIME);
      h = mod(h * h + x, FIELD_PRIME);
      h = mod(h * h + y, FIELD_PRIME);
      return h;
    }

    function generatePrivateKey() {
      const bytes = new Uint8Array(32);
      crypto.getRandomValues(bytes);
      let key = BigInt('0x' + Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join(''));
      key = mod(key, CURVE_ORDER - 1n) + 1n;
      return normalizePrivateKey(key);
    }

    function getPublicKey(privateKey) {
      return normalizePoint(pointMul(privateKey, G));
    }

    function toHex(n) {
      if (n === null || n === undefined) return '0x0';
      return '0x' + n.toString(16);
    }

    function fromHex(hex) {
      if (!hex || hex === '') return null;
      if (hex.startsWith('0x')) hex = hex.slice(2);
      return BigInt('0x' + hex);
    }

    function normalizeAddress(value) {
      if (!value) return '0x0';
      let v = value.trim();
      if (v.startsWith('0x') || v.startsWith('0X')) {
        v = v.slice(2);
      }
      if (v === '') return '0x0';
      // If not hex, try parsing as BigInt (decimal)
      if (!/^[0-9a-fA-F]+$/.test(v)) {
        try {
          return toHex(BigInt(value));
        } catch (e) {
          return value;
        }
      }
      // Strip leading zeros
      v = v.replace(/^0+/, '');
      if (v === '') v = '0';
      return '0x' + v.toLowerCase();
    }

    function truncate(hex, len = 12) {
      if (!hex) return '';
      if (hex.length <= len + 6) return hex;
      return hex.slice(0, len) + '...' + hex.slice(-4);
    }

    // Wallet connection - try get-starknet first, fall back to direct connection
    async function connectWallet() {
      const btn = document.getElementById('connect-btn');
      const preferenceEl = document.getElementById('wallet-preference');
      const preference = preferenceEl ? preferenceEl.value : 'auto';
      btn.disabled = true;
      btn.textContent = 'Connecting...';

      try {
        console.log('[wallet] Starting wallet connection...');
        
        let selectedWallet = null;
        let walletName = 'Wallet';
        
        if (preference === 'braavos') {
          if (!window.starknet_braavos) {
            throw new Error('Braavos wallet not detected in this browser.');
          }
          console.log('[wallet] Preference: Braavos');
          await window.starknet_braavos.enable();
          selectedWallet = window.starknet_braavos;
          walletName = 'Braavos';
        } else if (preference === 'argentx') {
          if (!window.starknet_argentX) {
            throw new Error('ArgentX wallet not detected in this browser.');
          }
          console.log('[wallet] Preference: ArgentX');
          await window.starknet_argentX.enable();
          selectedWallet = window.starknet_argentX;
          walletName = 'ArgentX';
        }

        // Method 1: Try get-starknet library if available
        if (!selectedWallet && typeof getStarknet !== 'undefined' && getStarknet.connect) {
          console.log('[wallet] Using get-starknet library...');
          try {
            selectedWallet = await getStarknet.connect({
              modalMode: 'alwaysAsk',
              modalTheme: 'dark'
            });
            if (selectedWallet) {
              walletName = selectedWallet.name || 'Wallet';
              console.log('[wallet] get-starknet connected:', walletName);
            }
          } catch (gsErr) {
            console.log('[wallet] get-starknet failed, trying direct connection:', gsErr.message);
          }
        }
        
        // Method 2: Fall back to direct wallet connection
        if (!selectedWallet) {
          console.log('[wallet] Trying direct wallet connection...');
          
          // Try Braavos first
          if (window.starknet_braavos) {
            console.log('[wallet] Found Braavos, connecting...');
            try {
              await window.starknet_braavos.enable();
              selectedWallet = window.starknet_braavos;
              walletName = 'Braavos';
              console.log('[wallet] Braavos connected');
            } catch (e) {
              console.log('[wallet] Braavos enable failed:', e.message);
            }
          }
          
          // Try ArgentX if Braavos didn't work
          if (!selectedWallet && window.starknet_argentX) {
            console.log('[wallet] Found ArgentX, connecting...');
            try {
              await window.starknet_argentX.enable();
              selectedWallet = window.starknet_argentX;
              walletName = 'ArgentX';
              console.log('[wallet] ArgentX connected');
            } catch (e) {
              console.log('[wallet] ArgentX enable failed:', e.message);
            }
          }
          
          // Try generic starknet object (if it's actually a wallet)
          if (!selectedWallet && window.starknet && window.starknet.enable) {
            console.log('[wallet] Found generic starknet wallet, connecting...');
            try {
              await window.starknet.enable();
              selectedWallet = window.starknet;
              walletName = window.starknet.name || 'Wallet';
              console.log('[wallet] Generic wallet connected');
            } catch (e) {
              console.log('[wallet] Generic wallet enable failed:', e.message);
            }
          }
        }
        
        // Check if we got a wallet
        if (!selectedWallet) {
          throw new Error('No wallet found. Please install ArgentX or Braavos extension.');
        }
        
        // User cancelled
        if (selectedWallet === null) {
          console.log('[wallet] User cancelled wallet selection');
          btn.disabled = false;
          btn.textContent = 'Connect Wallet';
          return;
        }
        
        console.log('[wallet] Wallet state:', {
          name: walletName,
          isConnected: selectedWallet.isConnected,
          hasAccount: !!selectedWallet.account,
          selectedAddress: selectedWallet.selectedAddress
        });
        
        // Enable if not already connected
        if (!selectedWallet.isConnected && selectedWallet.enable) {
          console.log('[wallet] Enabling wallet...');
          await selectedWallet.enable();
        }
        
        // Get account
        let walletAccount = selectedWallet.account;
        
        if (!walletAccount) {
          throw new Error('No account available. Please unlock your wallet and try again.');
        }
        
        wallet = selectedWallet;
        account = walletAccount;
        
        console.log('[wallet] Connected successfully!');
        console.log('[wallet] Address:', account.address);
        
        setupContracts();
        updateWalletUI(walletName);
        await refreshWalletChainId();
        startChainWatcher();
        if (wallet && typeof wallet.on === 'function') {
          try {
            wallet.on('networkChanged', refreshWalletChainId);
            wallet.on('chainChanged', refreshWalletChainId);
            wallet.on('accountsChanged', refreshWalletChainId);
          } catch (err) {
            console.warn('[wallet] Failed to attach network listeners:', err.message);
          }
        }

      } catch (err) {
        console.error('[wallet] Connection error:', err);
        console.error('[wallet] Error stack:', err.stack);
        
        // Provide helpful error message
        let errorMsg = err.message;
        if (err.message.includes('No wallet') || err.message.includes('not found')) {
          errorMsg = 'No Starknet wallet found.\n\nPlease install and enable:\n- ArgentX: chrome.google.com/webstore/detail/argent-x\n- Braavos: chrome.google.com/webstore/detail/braavos\n\nThen refresh this page.';
        } else if (err.message.includes('rejected') || err.message.includes('cancel')) {
          errorMsg = 'Connection rejected. Please approve the connection in your wallet.';
        }
        
        alert('Failed to connect: ' + errorMsg);
        btn.disabled = false;
        btn.textContent = 'Connect Wallet';
      }
    }

    function setupContracts() {
      // Prefer wallet/account provider
      provider = getProvider();
      if (!provider) {
        throw new Error('Provider not available from wallet');
      }
    }

    function updateWalletUI(walletName) {
      const btn = document.getElementById('connect-btn');
      const disconnectBtn = document.getElementById('disconnect-btn');
      const displayAddress = account.address;
      document.getElementById('wallet-status').textContent = walletName + ' Connected';
      document.getElementById('wallet-address').textContent = truncate(displayAddress, 16);
      const lookupInput = document.getElementById('lookup-address');
      if (lookupInput && !lookupInput.value) {
        lookupInput.value = displayAddress;
      }
      btn.textContent = 'Connected';
      btn.style.background = '#1a3a1a';
      btn.style.color = '#4ade80';
      btn.disabled = true;
      if (disconnectBtn) disconnectBtn.disabled = false;
    }

    function resetWalletUI() {
      const btn = document.getElementById('connect-btn');
      const disconnectBtn = document.getElementById('disconnect-btn');
      document.getElementById('wallet-status').textContent = 'Connect your wallet to interact with contracts';
      document.getElementById('wallet-address').textContent = '';
      btn.textContent = 'Connect Wallet';
      btn.style.background = '#4ade80';
      btn.style.color = '#000';
      btn.disabled = false;
      if (disconnectBtn) disconnectBtn.disabled = true;
    }

    function disconnectWallet() {
      wallet = null;
      account = null;
      provider = null;
      walletChainId = null;
      walletOnSepolia = false;
      stopChainWatcher();
      resetWalletUI();
      applyNetworkGuard();
      updateNetworkStatus();
      alert('Disconnected locally. If you want to fully revoke access, disconnect this site in your wallet extension.');
    }

    // Lookup meta-address from registry
    async function lookupMetaAddress() {
      const addressInput = document.getElementById('lookup-address').value;
      if (!addressInput) {
        alert('Please enter an address to lookup');
        return;
      }
      const address = normalizeAddress(addressInput);
      document.getElementById('lookup-address').value = address;

      const output = document.getElementById('lookup-output');
      output.style.display = 'block';
      output.innerHTML = '<div class="status pending"><div class="spinner"></div>Looking up...</div>';

      try {
        // Use direct RPC call instead of wallet provider (more reliable)
        const values = await callContract(CONFIG.registryAddress, 'get_stealth_meta_address', [address]);
        console.log('[lookup] Raw result:', values);

        const meta = parseMetaAddress(values);
        const spendingX = meta ? meta.spendingX : 0n;
        const spendingY = meta ? meta.spendingY : 0n;
        const schemeId = meta ? meta.schemeId : null;
        const expectedScheme = BigInt(CONFIG.schemeId);

        if (meta && spendingX !== 0n && spendingY !== 0n) {
          document.getElementById('recipient-key-x').value = toHex(spendingX);
          document.getElementById('recipient-key-y').value = toHex(spendingY);
          const schemeWarning = (schemeId !== null && schemeId !== expectedScheme)
            ? `<div class="status error" style="margin-top: 0.5rem;">Warning: registry scheme_id ${schemeId.toString()} does not match demo scheme ${expectedScheme.toString()}.</div>`
            : '';
          output.innerHTML = `
            <div class="status success">Found meta-address</div>
            <div class="output-row" style="margin-top: 0.5rem;">
              <span class="output-label">Key X:</span>
              <span class="output-value">${truncate(toHex(spendingX))}</span>
            </div>
            <div class="output-row">
              <span class="output-label">Key Y:</span>
              <span class="output-value">${truncate(toHex(spendingY))}</span>
            </div>
            <div class="output-row">
              <span class="output-label">Scheme ID:</span>
              <span class="output-value">${schemeId !== null ? schemeId.toString() : 'n/a'}</span>
            </div>
            ${schemeWarning}
          `;
        } else {
          output.innerHTML = '<div class="status error">No meta-address registered for this user</div>';
        }
      } catch (err) {
        console.error('Lookup error:', err);
        output.innerHTML = `<div class="status error">Lookup failed: ${err.message}</div>`;
      }
    }

    // Generate stealth address
    function generateStealth() {
      const keyX = document.getElementById('recipient-key-x').value;
      const keyY = document.getElementById('recipient-key-y').value;

      if (!keyX || !keyY) {
        alert('Please enter recipient public key');
        return;
      }

      const recipientPub = normalizePoint({ x: fromHex(keyX), y: fromHex(keyY) });

      // Generate ephemeral key
      const ephemeralPriv = generatePrivateKey();
      const ephemeralPub = getPublicKey(ephemeralPriv);

      // Compute shared secret
      const sharedSecret = pointMul(ephemeralPriv, recipientPub);

      // Hash shared secret
      const hashS = mod(simpleHash(sharedSecret.x, sharedSecret.y), CURVE_ORDER);

      // Compute stealth public key
      const hashPoint = pointMul(hashS, G);
      const stealthPub = normalizePoint(pointAdd(recipientPub, hashPoint));

      // Compute view tag
      const viewTag = Number(hashS % 256n);

      // Generate salt
      const salt = simpleHash(ephemeralPub.x, ephemeralPub.y);

      // Store for deployment
      stealthData = {
        ephemeralPriv,
        ephemeralPub,
        stealthPub,
        viewTag,
        salt,
        sharedSecret
      };

      const output = document.getElementById('stealth-output');
      output.style.display = 'block';
      output.innerHTML = `
        <div class="milestone">Milestone reached: one-time stealth address computed.</div>
        <div class="status success">Stealth address generated</div>
        <div class="divider"></div>
        <div class="output-row">
          <span class="output-label">Ephemeral R.x:</span>
          <span class="output-value">${truncate(toHex(ephemeralPub.x))}</span>
        </div>
        <div class="output-row">
          <span class="output-label">Ephemeral R.y:</span>
          <span class="output-value">${truncate(toHex(ephemeralPub.y))}</span>
        </div>
        <div class="divider"></div>
        <div class="output-row">
          <span class="output-label">Stealth P.x:</span>
          <span class="output-value">${truncate(toHex(stealthPub.x))}</span>
        </div>
        <div class="output-row">
          <span class="output-label">Stealth P.y:</span>
          <span class="output-value">${truncate(toHex(stealthPub.y))}</span>
        </div>
        <div class="output-row">
          <span class="output-label">View Tag:</span>
          <span class="output-value">${viewTag}</span>
        </div>
        <div class="divider"></div>
        <div class="info-box">
          Ready to deploy. Click "Deploy & Announce" to create the stealth account on-chain.
        </div>
      `;

      applyNetworkGuard();
    }

    // Deploy stealth account and announce
    async function deployAndAnnounce() {
      if (!account) {
        alert('Please connect your wallet first');
        return;
      }
      if (!await ensureSepoliaWallet('deploying and announcing')) {
        return;
      }
      if (!await ensureStrkBalance('deploying and announcing', '0.03')) {
        return;
      }

      if (!stealthData) {
        alert('Please generate a stealth address first');
        return;
      }

      const btn = document.getElementById('deploy-btn');
      btn.disabled = true;
      btn.textContent = 'Deploying...';

      const output = document.getElementById('deploy-output');
      output.style.display = 'block';
      output.innerHTML = '<div class="status pending"><div class="spinner"></div>Deploying stealth account...</div>';

      try {
        // Deploy stealth account
        const deployCall = makeCall(CONFIG.factoryAddress, 'deploy_stealth_account', [
          toHex(stealthData.stealthPub.x),
          toHex(stealthData.stealthPub.y),
          toHex(stealthData.salt)
        ]);

        const deployTx = await account.execute([deployCall]);
        lastDeployTxHash = deployTx.transaction_hash;
        
        output.innerHTML = `
          <div class="status pending"><div class="spinner"></div>Waiting for deployment confirmation...</div>
          <div class="output-row" style="margin-top: 0.5rem;">
            <span class="output-label">Deploy TX:</span>
            <a href="https://sepolia.starkscan.co/tx/${deployTx.transaction_hash}" target="_blank" class="tx-link">${truncate(deployTx.transaction_hash)}</a>
          </div>
        `;

        await waitForTx(deployTx.transaction_hash);

        let stealthAddress = null;
        try {
          stealthAddress = await computeStealthContractAddress();
          console.log('[deploy] Computed stealth address:', stealthAddress);
        } catch (err) {
          console.error('[deploy] compute_stealth_address failed:', err);
          output.innerHTML = `<div class="status error">Error computing stealth address: ${err.message}</div>`;
          btn.disabled = false;
          btn.textContent = 'Deploy & Announce';
          return;
        }

        // Now announce
        output.innerHTML += '<div class="status pending" id="announce-status" style="margin-top: 0.5rem;"><div class="spinner"></div>Publishing announcement... (check wallet approval)</div>';
        const announceStatusEl = document.getElementById('announce-status');
        const announceReminder = setTimeout(() => {
          if (announceStatusEl) {
            announceStatusEl.innerHTML = '<div class="spinner"></div>Waiting for wallet approval... If no popup, open your wallet extension and confirm.';
          }
        }, 8000);

        const announceCall = makeCall(CONFIG.registryAddress, 'announce', [
          CONFIG.schemeId,
          toHex(stealthData.ephemeralPub.x),
          toHex(stealthData.ephemeralPub.y),
          stealthAddress,
          toHex(BigInt(stealthData.viewTag)),
          '0x0' // metadata
        ]);
        lastAnnounceCall = announceCall;

        const { timedOut, tx } = await executeWithTimeout(account.execute([announceCall]), 20000);
        clearTimeout(announceReminder);
        if (timedOut || !tx) {
          output.innerHTML = `
            <div class="status pending">Announcement submitted. Waiting for wallet response...</div>
            <div class="divider"></div>
            <div class="info-box">
              If you already approved the announcement in your wallet, paste the tx hash below and click Finalize.
            </div>
            <div class="input-group" style="margin-top: 0.75rem;">
              <div class="input-label">Announcement TX Hash (from wallet activity)</div>
              <input type="text" id="announce-tx-hash" placeholder="0x...">
            </div>
            <button onclick="finalizeAnnouncement()" class="btn-primary">Finalize</button>
            <button onclick="retryAnnouncement()" style="margin-left: 0.5rem;">Retry Announce</button>
          `;
          btn.disabled = false;
          btn.textContent = 'Deploy & Announce';
          return;
        }

        lastAnnounceTxHash = tx.transaction_hash;
        await waitForTx(lastAnnounceTxHash);
        renderDeploymentSuccess(deployTx.transaction_hash, lastAnnounceTxHash);

      } catch (err) {
        console.error('Deploy error:', err);
        output.innerHTML = `<div class="status error">Error: ${err.message}</div>`;
        btn.disabled = false;
        btn.textContent = 'Deploy & Announce';
      }
    }

    // Generate recipient keys
    function generateRecipientKeys() {
      const privateKey = generatePrivateKey();
      const publicKey = getPublicKey(privateKey);

      document.getElementById('register-key-x').value = toHex(publicKey.x);
      document.getElementById('register-key-y').value = toHex(publicKey.y);

      const output = document.getElementById('recipient-keys-output');
      output.style.display = 'block';
      output.innerHTML = `
        <div class="status success">Keys generated</div>
        <div class="divider"></div>
        <div class="output-row">
          <span class="output-label">Private Key:</span>
          <span class="output-value" style="color: #f87171;">${truncate(toHex(privateKey))}</span>
        </div>
        <div class="output-row">
          <span class="output-label">Public Key X:</span>
          <span class="output-value">${truncate(toHex(publicKey.x))}</span>
        </div>
        <div class="output-row">
          <span class="output-label">Public Key Y:</span>
          <span class="output-value">${truncate(toHex(publicKey.y))}</span>
        </div>
        <div class="divider"></div>
        <div class="info-box" style="background: #2a1a1a; border-color: #5f1e1e; color: #fca5a5;">
          SAVE YOUR PRIVATE KEY! You need it to claim payments. It will not be shown again.
          <br><br>
          <code style="font-size: 0.65rem; word-break: break-all;">${toHex(privateKey)}</code>
        </div>
      `;

      // Store for scan tab
      document.getElementById('scan-private-key').value = toHex(privateKey);
    }

    // Register meta-address
    async function registerMetaAddress() {
      if (!account) {
        alert('Please connect your wallet first');
        return;
      }
      if (!await ensureSepoliaWallet('registering the meta-address')) {
        return;
      }
      if (!await ensureStrkBalance('registering the meta-address', '0.01')) {
        return;
      }

      const keyX = document.getElementById('register-key-x').value;
      const keyY = document.getElementById('register-key-y').value;

      if (!keyX || !keyY) {
        alert('Please generate or enter your keys first');
        return;
      }

      const registerBtn = document.getElementById('register-btn');
      const updateBtn = document.getElementById('update-btn');
      registerBtn.disabled = true;
      updateBtn.disabled = true;
      registerBtn.textContent = 'Registering...';

      const output = document.getElementById('register-output');
      output.style.display = 'block';
      output.innerHTML = '<div class="status pending"><div class="spinner"></div>Registering meta-address...</div>';

      try {
        const alreadyRegistered = await hasMetaAddress(account.address);
        if (alreadyRegistered) {
          output.innerHTML = '<div class="status pending"><div class="spinner"></div>Already registered. Updating meta-address...</div>';
          registerBtn.textContent = 'Register On-Chain';
          registerBtn.disabled = false;
          updateBtn.disabled = false;
          await updateMetaAddress(true);
          return;
        }

        const call = makeCall(CONFIG.registryAddress, 'register_stealth_meta_address', [
          keyX,
          keyY,
          keyX,
          keyY,
          CONFIG.schemeId
        ]);
        const tx = await account.execute([call]);

        output.innerHTML = `
          <div class="status pending"><div class="spinner"></div>Waiting for confirmation...</div>
          <div class="output-row" style="margin-top: 0.5rem;">
            <span class="output-label">TX:</span>
            <a href="https://sepolia.starkscan.co/tx/${tx.transaction_hash}" target="_blank" class="tx-link">${truncate(tx.transaction_hash)}</a>
          </div>
        `;

        await waitForTx(tx.transaction_hash);

        output.innerHTML = `
          <div class="milestone">Milestone reached: meta-address published to the registry.</div>
          <div class="status success">Meta-address registered!</div>
          <div class="divider"></div>
          <div class="output-row">
            <span class="output-label">Address:</span>
            <span class="output-value">${truncate(account.address)}</span>
          </div>
          <div class="divider"></div>
          <div class="output-row">
            <span class="output-label">TX:</span>
            <a href="https://sepolia.starkscan.co/tx/${tx.transaction_hash}" target="_blank" class="tx-link">${truncate(tx.transaction_hash)}</a>
          </div>
          <div class="divider"></div>
          <div class="info-box" style="background: #1a2a1a; border-color: #1e5f1e; color: #a5fca5;">
            <strong>Recipient setup complete!</strong>
            <br><br>
            Your meta-address is now public. Share your Starknet address with senders so they can look up your meta-address.
          </div>
          <div class="next-steps">
            <div style="margin-top: 0.6rem;">
              <button class="btn-primary" onclick="selectTab('send')">Go to Send (as sender)</button>
            </div>
          </div>
        `;

        registerBtn.textContent = 'Registered';
        updateBtn.disabled = false;

      } catch (err) {
        console.error('Register error:', err);
        output.innerHTML = `<div class="status error">Error: ${err.message}</div>`;
        registerBtn.disabled = false;
        updateBtn.disabled = false;
        registerBtn.textContent = 'Register On-Chain';
      }
    }

    async function updateMetaAddress(fromRegister) {
      if (!account) {
        alert('Please connect your wallet first');
        return;
      }
      if (!await ensureSepoliaWallet('updating the meta-address')) {
        return;
      }
      if (!await ensureStrkBalance('updating the meta-address', '0.01')) {
        return;
      }

      const keyX = document.getElementById('register-key-x').value;
      const keyY = document.getElementById('register-key-y').value;

      if (!keyX || !keyY) {
        alert('Please generate or enter your keys first');
        return;
      }

      const registerBtn = document.getElementById('register-btn');
      const updateBtn = document.getElementById('update-btn');
      registerBtn.disabled = true;
      updateBtn.disabled = true;
      updateBtn.textContent = 'Updating...';

      const output = document.getElementById('register-output');
      output.style.display = 'block';
      if (!fromRegister) {
        output.innerHTML = '<div class="status pending"><div class="spinner"></div>Updating meta-address...</div>';
      }

      try {
        const call = makeCall(CONFIG.registryAddress, 'update_stealth_meta_address', [
          keyX,
          keyY,
          keyX,
          keyY,
          CONFIG.schemeId
        ]);
        const tx = await account.execute([call]);

        output.innerHTML = `
          <div class="status pending"><div class="spinner"></div>Waiting for confirmation...</div>
          <div class="output-row" style="margin-top: 0.5rem;">
            <span class="output-label">TX:</span>
            <a href="https://sepolia.starkscan.co/tx/${tx.transaction_hash}" target="_blank" class="tx-link">${truncate(tx.transaction_hash)}</a>
          </div>
        `;

        await waitForTx(tx.transaction_hash);

        output.innerHTML = `
          <div class="milestone">Milestone reached: meta-address updated on-chain.</div>
          <div class="status success">Meta-address updated!</div>
          <div class="divider"></div>
          <div class="output-row">
            <span class="output-label">Address:</span>
            <span class="output-value">${truncate(account.address)}</span>
          </div>
          <div class="divider"></div>
          <div class="output-row">
            <span class="output-label">TX:</span>
            <a href="https://sepolia.starkscan.co/tx/${tx.transaction_hash}" target="_blank" class="tx-link">${truncate(tx.transaction_hash)}</a>
          </div>
          <div class="divider"></div>
          <div class="info-box" style="background: #1a2a1a; border-color: #1e5f1e; color: #a5fca5;">
            <strong>Recipient setup complete!</strong>
            <br><br>
            Your meta-address has been updated. Share your Starknet address with senders so they can look it up.
          </div>
          <div class="next-steps">
            <div style="margin-top: 0.6rem;">
              <button class="btn-primary" onclick="selectTab('send')">Go to Send (as sender)</button>
            </div>
          </div>
        `;

        registerBtn.textContent = 'Registered';
        updateBtn.textContent = 'Updated';
        registerBtn.disabled = false;
        updateBtn.disabled = false;
      } catch (err) {
        console.error('Update error:', err);
        output.innerHTML = `<div class="status error">Error: ${err.message}</div>`;
        registerBtn.disabled = false;
        updateBtn.disabled = false;
        updateBtn.textContent = 'Update On-Chain';
      }
    }

    // Scan announcements
    async function scanAnnouncements() {
      const privateKeyHex = document.getElementById('scan-private-key').value;
      if (!privateKeyHex) {
        alert('Please enter your private key');
        return;
      }

      const privateKey = fromHex(privateKeyHex);
      const publicKey = getPublicKey(privateKey);

      const status = document.getElementById('scan-status');
      status.style.display = 'flex';
      status.className = 'status pending';
      status.innerHTML = '<div class="spinner"></div>Scanning announcements...';

      const results = document.getElementById('scan-results');
      results.innerHTML = '<div style="color: #666;">Scanning...</div>';

      try {
        console.log('[scan] Starting scan for registry:', CONFIG.registryAddress);
        console.log('[scan] Public key X:', truncate(toHex(publicKey.x)));
        const allEvents = await fetchAnnouncementEvents();
        const normalizedRegistry = normalizeAddress(CONFIG.registryAddress);
        const relevant = allEvents.filter((ev) => {
          const from = normalizeAddress(ev.from_address || '');
          if (from !== normalizedRegistry) return false;
          if (!ev.keys || !ev.data) return false;
          return ev.keys.length >= 3 && ev.data.length >= 5;
        });

        const matches = [];
        let html = `
          <div style="color: #666; margin-bottom: 1rem;">
            Scanned announcements from registry contract.
            <br><br>
            Your public key: ${truncate(toHex(publicKey.x))}
            <br>
            Total announcements scanned: ${relevant.length}
          </div>
          <div class="divider"></div>
        `;

        for (let idx = 0; idx < relevant.length; idx += 1) {
          const ev = relevant[idx];
          const data = ev.data || [];
          const keys = ev.keys || [];
          const ephemeralX = data[0];
          const ephemeralY = data[1];
          const stealthAddressRaw = data[2];
          const stealthAddress = normalizeAddress(stealthAddressRaw);
          const schemeIdOnChain = keys[1] ? BigInt(keys[1]) : null;
          const viewTagOnChain = keys[2] ? Number(BigInt(keys[2]) % 256n) : null;
          const expectedSchemeId = BigInt(CONFIG.schemeId);
          const schemeMatches = schemeIdOnChain === null || schemeIdOnChain === expectedSchemeId;

          const ephemPoint = normalizePoint({ x: fromHex(ephemeralX), y: fromHex(ephemeralY) });
          const sharedSecret = pointMul(privateKey, ephemPoint);
          const hashS = mod(simpleHash(sharedSecret.x, sharedSecret.y), CURVE_ORDER);
          const computedViewTag = Number(hashS % 256n);

          const isMatch = schemeMatches && (viewTagOnChain !== null) && (computedViewTag === viewTagOnChain);
          if (isMatch) {
            const stealthPriv = normalizePrivateKey(mod(privateKey + hashS, CURVE_ORDER));
            matches.push({
              txHash: ev.transaction_hash,
              index: data[4],
              stealthPriv,
              stealthAddress,
              viewTag: computedViewTag
            });
          }

          html += `
            <div class="event-item">
              <div><strong>Announcement ${idx + 1}</strong> ${isMatch ? '<span class="match-badge">MATCH</span>' : ''}</div>
              <div>Ephemeral R.x: ${truncate(ephemeralX)}</div>
              <div>Ephemeral R.y: ${truncate(ephemeralY)}</div>
              <div>Scheme ID: ${schemeIdOnChain !== null ? schemeIdOnChain.toString() : 'n/a'}</div>
              <div>View Tag: ${viewTagOnChain !== null ? viewTagOnChain : 'n/a'} (computed ${computedViewTag})</div>
              <div>Stealth Address: ${truncate(stealthAddress)}</div>
              <div>TX: <a href="https://sepolia.starkscan.co/tx/${ev.transaction_hash}" target="_blank" class="tx-link">${truncate(ev.transaction_hash)}</a></div>
            </div>
          `;
        }

        if (relevant.length === 0) {
          html += `<div style="color: #888; font-size: 0.7rem;">No announcement events found yet.</div>`;
        }

        if (matches.length > 0) {
          const enrichedMatches = await Promise.all(matches.map(async (m) => {
            let balance = null;
            let balanceText = 'n/a';
            try {
              balance = await getStrkBalance(normalizeAddress(m.stealthAddress));
              balanceText = `${formatUnits(balance)} STRK`;
            } catch (err) {
              console.warn('[scan] balance lookup failed:', err.message);
            }
            return { ...m, balance, balanceText, hasFunds: balance ? balance > 0n : false };
          }));
          let matchRows = '';
          enrichedMatches.forEach((m, i) => {
            matchRows += `
              <div class="output-row">
                <span class="output-label">Match ${i + 1} TX:</span>
                <a href="https://sepolia.starkscan.co/tx/${m.txHash}" target="_blank" class="tx-link">${truncate(m.txHash)}</a>
              </div>
              <div class="output-row">
                <span class="output-label">Stealth Address:</span>
                <span class="output-value">${truncate(m.stealthAddress)}</span>
              </div>
              <div class="output-row">
                <span class="output-label">Balance:</span>
                <span class="output-value">${m.balanceText}</span>
              </div>
              <div class="output-row">
                <span class="output-label">Stealth Private Key:</span>
                <span class="output-value">${truncate(toHex(m.stealthPriv))}</span>
              </div>
              <div class="divider"></div>
            `;
          });

          lastMatches = enrichedMatches;

          html += `
            <div class="divider"></div>
            <div class="milestone">Milestone reached: this announcement belongs to you.</div>
            <div class="info-box">
              ${matches.length} matching announcement(s) found.
              <div class="divider"></div>
              <strong>What this means:</strong> you control the stealth account(s) listed below. If the balance is 0, the sender has not funded yet. If balance &gt; 0, you can spend using the derived stealth private key (outside this demo).
              <div class="divider"></div>
              ${matchRows}
              <div style="color: #fca5a5; font-size: 0.7rem;">
                Keep stealth private keys secure. They control the stealth accounts.
              </div>
            </div>
          `;
        }

        results.innerHTML = html;

        status.className = 'status success';
        status.innerHTML = 'Scan complete';

      } catch (err) {
        console.error('Scan error:', err);
        status.className = 'status error';
        status.innerHTML = 'Scan failed: ' + err.message;
      }
    }

    // Detect wallets and show in debug panel
    async function detectWallets() {
      const output = document.getElementById('debug-output');
      let html = '';
      
      // Check for wallet objects (not starknet.js library)
      const starknetObjects = Object.keys(window).filter(k => 
        k.startsWith('starknet_') && k !== 'starknet'
      );
      
      html += `<strong>Direct wallet objects:</strong> ${starknetObjects.length > 0 ? starknetObjects.join(', ') : 'none found'}<br>`;
      
      if (window.starknet_braavos) {
        html += `<span style="color: #4ade80;">starknet_braavos: FOUND</span><br>`;
      }
      
      if (window.starknet_argentX) {
        html += `<span style="color: #4ade80;">starknet_argentX: FOUND</span><br>`;
      }
      
      // Check if window.starknet is library or wallet
      if (window.starknet) {
        const isLibrary = window.starknet.Account && window.starknet.Contract && window.starknet.RpcProvider;
        if (isLibrary) {
          html += `<span style="color: #f59e0b;">window.starknet: starknet.js LIBRARY (not a wallet)</span><br>`;
        } else {
          html += `<span style="color: #4ade80;">window.starknet: WALLET</span><br>`;
        }
      }
      
      // Check get-starknet
      html += `<br><strong>get-starknet library:</strong> ${typeof getStarknet !== 'undefined' ? 'loaded' : 'not loaded'}<br>`;
      
      if (typeof getStarknet !== 'undefined' && getStarknet.getAvailableWallets) {
        try {
          const wallets = await getStarknet.getAvailableWallets();
          html += `<strong>Available wallets:</strong> ${wallets.length > 0 ? wallets.map(w => w.name || w.id).join(', ') : 'none detected'}<br>`;
          console.log('[detectWallets] Available wallets:', wallets);
        } catch (e) {
          html += `<span style="color: #f87171;">Error getting wallets: ${e.message}</span><br>`;
        }
      }
      
      html += `<br><span style="color: #888;">If no wallets detected, make sure extension is installed and enabled for localhost</span>`;
      
      output.innerHTML = html;
      console.log('[detectWallets] Check complete');
    }

    function initDebugPanel() {
      const panel = document.getElementById('debug-panel');
      const btn = document.getElementById('debug-toggle');
      const params = new URLSearchParams(window.location.search);
      const show = params.get('debug') === '1' || localStorage.getItem('showWalletDebug') === '1';
      panel.style.display = show ? 'block' : 'none';
      btn.textContent = show ? 'Hide Wallet Debug' : 'Show Wallet Debug';
      if (show) {
        setTimeout(detectWallets, 1000);
      }
    }

    function toggleDebugPanel() {
      const panel = document.getElementById('debug-panel');
      const btn = document.getElementById('debug-toggle');
      const visible = panel.style.display === 'block';
      const next = !visible;
      panel.style.display = next ? 'block' : 'none';
      btn.textContent = next ? 'Hide Wallet Debug' : 'Show Wallet Debug';
      localStorage.setItem('showWalletDebug', next ? '1' : '0');
      if (next) {
        setTimeout(detectWallets, 500);
      }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      initDebugPanel();
      updateNetworkStatus();
      applyNetworkGuard();
      renderMainnetUsd();
      console.log('[init] Page loaded, wallet detection scheduled');
    });

    window.addEventListener('focus', () => {
      refreshWalletChainId();
    });
  </script>
</body>
</html>
